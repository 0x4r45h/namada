//! Implementation of chain initialization for the Shell
use std::collections::HashMap;
use std::ops::ControlFlow;

use namada::ledger::parameters::Parameters;
use namada::ledger::storage::traits::StorageHasher;
use namada::ledger::storage::{DBIter, DB};
use namada::ledger::storage_api::token::{credit_tokens, write_denom};
use namada::ledger::storage_api::StorageWrite;
use namada::ledger::{ibc, pos};
use namada::proof_of_stake::BecomeValidator;
use namada::types::hash::Hash as CodeHash;
use namada::types::key::*;
use namada::types::storage::KeySeg;
use namada::types::time::{DateTimeUtc, TimeZone, Utc};
use namada::vm::validate_untrusted_wasm;
use namada_sdk::eth_bridge::EthBridgeStatus;
use namada_sdk::proof_of_stake::PosParams;

use super::*;
use crate::config::genesis::chain::{
    FinalizedEstablishedAccountTx, FinalizedTokenConfig,
    FinalizedValidatorAccountTx,
};
use crate::config::genesis::templates::{TokenBalances, TokenConfig};
use crate::config::genesis::transactions::{
    BondTx, EstablishedAccountTx, TransferTx, ValidatorAccountTx,
};
use crate::facade::tendermint_proto::google::protobuf;
use crate::facade::tower_abci::{request, response};
use crate::wasm_loader;

/// Errors that represent panics in normal flow but get demoted to errors
/// when dry-running genesis files in order to accumulate as many problems
/// as possible in a report.
#[derive(Error, Debug, Clone, PartialEq)]
enum Panic {
    #[error(
        "No VP found matching the expected implicit VP sha256 hash: \
         {0}\n(this will be `None` if no wasm file was found for the implicit \
         vp)"
    )]
    MissingImplicitVP(String),
    #[error("Missing validity predicate for {0}")]
    MissingVpWasmConfig(String),
    #[error("Could not find checksums.json file")]
    ChecksumsFile,
    #[error("Invalid wasm code sha256 hash for {0}")]
    Checksum(String),
    #[error(
        "Config for token '{0}' with configured balance not found in genesis"
    )]
    MissingTokenConfig(String),
    #[error("Failed to read wasm {0} with reason: {1}")]
    ReadingWasm(String, String),
}

/// Warnings generated by problems in genesis files.
#[derive(Error, Debug, PartialEq)]
enum Warning {
    #[error("The wasm {0} isn't whitelisted.")]
    WhitelistedWasm(String),
    #[error("Genesis init genesis validator tx for {0} failed with {1}.")]
    Validator(String, String),
    #[error("Genesis token transfer tx uses an unknown token alias {0}.")]
    BadToken(String),
    #[error("Genesis token transfer tx uses an unknown target alias {0}.")]
    UnknownTarget(String),
    #[error(
        "Genesis transfer from {0} to {1} of {2} {3} failed with reason: {4}"
    )]
    FailedTransfer(String, String, token::DenominatedAmount, String, String),
    #[error("Cannot find bond source address with alias \"{0}\".")]
    MissingBondAlias(String),
    #[error("Cannot find bond validator address with alias \"{0}\".")]
    MissingValidatorAlias(String),
    #[error(
        "Genesis bond by {0} to validiator {1} of {2} NAM failed with reason: \
         {3}"
    )]
    FailedBond(String, String, token::DenominatedAmount, String),
}

impl<D, H> Shell<D, H>
where
    D: DB + for<'iter> DBIter<'iter> + Sync + 'static,
    H: StorageHasher + Sync + 'static,
{
    /// Create a new genesis for the chain with specified id. This includes
    /// 1. A set of initial users and tokens
    /// 2. Setting up the validity predicates for both users and tokens
    /// 3. Validators
    /// 4. The PoS system
    /// 5. The Ethereum bridge parameters
    ///
    /// INVARIANT: This method must not commit the state changes to DB.
    pub fn init_chain(
        &mut self,
        init: request::InitChain,
        #[cfg(any(test, feature = "testing"))] _num_validators: u64,
    ) -> Result<response::InitChain> {
        let mut response = response::InitChain::default();
        let chain_id = self.wl_storage.storage.chain_id.to_string();
        if chain_id.as_str() != init.chain_id.as_str() {
            return Err(Error::ChainId(format!(
                "Current chain ID: {}, Tendermint chain ID: {}",
                chain_id, init.chain_id
            )));
        }

        // Read the genesis files
        #[cfg(any(
            feature = "integration",
            not(any(test, feature = "benches"))
        ))]
        let genesis = {
            let chain_dir = self.base_dir.join(chain_id);
            genesis::chain::Finalized::read_toml_files(&chain_dir)
                .expect("Missing genesis files")
        };
        #[cfg(all(
            any(test, feature = "benches"),
            not(feature = "integration")
        ))]
        let genesis = {
            let chain_dir = self.base_dir.join(chain_id);
            genesis::make_dev_genesis(_num_validators, chain_dir)
        };
        #[cfg(all(
            any(test, feature = "benches"),
            not(feature = "integration")
        ))]
        {
            // update the native token from the genesis file
            let native_token = genesis.get_native_token().clone();
            self.wl_storage.storage.native_token = native_token;
        }
        let mut validation = InitChainValidation::new(self, false);
        validation.run(
            init,
            genesis,
            #[cfg(any(test, feature = "testing"))]
            _num_validators,
        );
        // propogate errors or panic
        validation.error_out()?;
        // Set the initial validator set
        response.validators = self
            .get_abci_validator_updates(true)
            .expect("Must be able to set genesis validator set");
        debug_assert!(!response.validators.is_empty());
        Ok(response)
    }
}

impl<'shell, D, H> InitChainValidation<'shell, D, H>
where
    D: DB + for<'iter> DBIter<'iter> + Sync + 'static,
    H: StorageHasher + Sync + 'static,
{
    pub fn run(
        &mut self,
        init: request::InitChain,
        genesis: genesis::chain::Finalized,
        #[cfg(any(test, feature = "testing"))] _num_validators: u64,
    ) -> ControlFlow<()> {
        let ts: protobuf::Timestamp = init.time.expect("Missing genesis time");
        let initial_height = init
            .initial_height
            .try_into()
            .expect("Unexpected block height");
        // TODO hacky conversion, depends on https://github.com/informalsystems/tendermint-rs/issues/870
        let genesis_time: DateTimeUtc = (Utc
            .timestamp_opt(ts.seconds, ts.nanos as u32))
        .single()
        .expect("genesis time should be a valid timestamp")
        .into();

        // Initialize protocol parameters
        let parameters = genesis.get_chain_parameters(&self.wasm_dir);
        self.store_wasms(&parameters)?;
        parameters.init_storage(&mut self.wl_storage).unwrap();

        // Initialize governance parameters
        let gov_params = genesis.get_gov_params();
        gov_params.init_storage(&mut self.wl_storage).unwrap();

        // configure the Ethereum bridge if the configuration is set.
        if let Some(config) = genesis.get_eth_bridge_params() {
            tracing::debug!("Initializing Ethereum bridge storage.");
            config.init_storage(&mut self.wl_storage);
            self.update_eth_oracle();
        } else {
            self.wl_storage
                .write_bytes(
                    &namada::eth_bridge::storage::active_key(),
                    EthBridgeStatus::Disabled.serialize_to_vec(),
                )
                .unwrap();
        }

        // Depends on parameters being initialized
        self.wl_storage
            .storage
            .init_genesis_epoch(initial_height, genesis_time, &parameters)
            .expect("Initializing genesis epoch must not fail");

        // PoS system depends on epoch being initialized
        let pos_params = genesis.get_pos_params();
        let (current_epoch, _gas) = self.wl_storage.storage.get_current_epoch();
        pos::namada_proof_of_stake::init_genesis(
            &mut self.wl_storage,
            &pos_params,
            current_epoch,
        )
        .expect("Must be able to initialize PoS genesis storage");

        // PGF parameters
        let pgf_params = genesis.get_pgf_params();
        pgf_params
            .init_storage(&mut self.wl_storage)
            .expect("Should be able to initialized PGF at genesis");

        // Loaded VP code cache to avoid loading the same files multiple times
        let mut vp_cache: HashMap<String, Vec<u8>> = HashMap::default();
        self.init_token_accounts(&genesis);
        self.init_token_balances(&genesis);
        self.apply_genesis_txs_established_account(&genesis, &mut vp_cache);
        self.apply_genesis_txs_validator_account(
            &genesis,
            &mut vp_cache,
            &pos_params,
            current_epoch,
        );
        self.apply_genesis_txs_transfer(&genesis);
        self.apply_genesis_txs_bonds(&genesis);

        pos::namada_proof_of_stake::store_total_consensus_stake(
            &mut self.wl_storage,
            Default::default(),
        )
        .expect("Could not compute total consensus stake at genesis");
        // This has to be done after `apply_genesis_txs_validator_account`
        pos::namada_proof_of_stake::copy_genesis_validator_sets(
            &mut self.wl_storage,
            &pos_params,
            current_epoch,
        )
        .expect("Must be able to copy PoS genesis validator sets");

        ibc::init_genesis_storage(&mut self.wl_storage);
        ControlFlow::Continue(())
    }

    /// Look-up WASM code of a genesis VP by its name
    fn lookup_vp(
        &mut self,
        name: &str,
        genesis: &genesis::chain::Finalized,
        vp_cache: &mut HashMap<String, Vec<u8>>,
    ) -> ControlFlow<(), Vec<u8>> {
        use std::collections::hash_map::Entry;
        let Some(vp_filename) =
            self.validate(
                genesis
                    .vps
                    .wasm
                    .get(name)
                    .map(|conf| conf.filename.clone())
                    .ok_or_else(|| {
                        Panic::MissingVpWasmConfig(name.to_string())
                }))
                .or_placeholder(None)? else {
            return self.proceed_with(vec![]);
        };
        let code = match vp_cache.entry(vp_filename.clone()) {
            Entry::Occupied(o) => o.get().clone(),
            Entry::Vacant(v) => {
                let code = self
                    .validate(
                        wasm_loader::read_wasm(&self.wasm_dir, &vp_filename)
                            .map_err(|e| {
                                Panic::ReadingWasm(vp_filename, e.to_string())
                            }),
                    )
                    .or_placeholder(Some(vec![]))?
                    .unwrap();
                v.insert(code).clone()
            }
        };
        self.proceed_with(code)
    }

    fn store_wasms(&mut self, params: &Parameters) -> ControlFlow<()> {
        let Parameters {
            tx_whitelist,
            vp_whitelist,
            implicit_vp_code_hash,
            ..
        } = params;
        let mut is_implicit_vp_stored = false;

        let Some(checksums) = self.validate(
            wasm_loader::Checksums::read_checksums(&self.wasm_dir)
                .map_err(|_| Panic::ChecksumsFile)
        ).or_placeholder(None)? else {
            return self.proceed_with(());
        };

        for (name, full_name) in checksums.0.iter() {
            let code = self
                .validate(
                    wasm_loader::read_wasm(&self.wasm_dir, name)
                        .map_err(Error::ReadingWasm),
                )
                .or_placeholder(Some(vec![]))?
                .unwrap();

            let code_hash = CodeHash::sha256(&code);
            let code_len = self
                .validate(
                    u64::try_from(code.len())
                        .map_err(|e| Error::LoadingWasm(e.to_string())),
                )
                .or_placeholder(Some(1))?
                .unwrap();

            let elements = full_name.split('.').collect::<Vec<&str>>();
            let checksum = self
                .validate(elements.get(1).map(|c| c.to_uppercase()).ok_or_else(
                    || {
                        Error::LoadingWasm(format!(
                            "invalid full name: {}",
                            full_name
                        ))
                    },
                ))
                .or_placeholder(Some(code_hash.to_string()))?
                .unwrap();

            self.validate(if checksum == code_hash.to_string() {
                Ok(())
            } else {
                Err(Panic::Checksum(name.to_string()))
            })
            .or_placeholder(None)?;

            if (tx_whitelist.is_empty() && vp_whitelist.is_empty())
                || tx_whitelist.contains(&code_hash.to_string().to_lowercase())
                || vp_whitelist.contains(&code_hash.to_string().to_lowercase())
            {
                self.validate(
                    validate_untrusted_wasm(&code)
                        .map_err(|e| Error::LoadingWasm(e.to_string())),
                )
                .or_placeholder(None)?;

                #[cfg(not(test))]
                if name.starts_with("tx_") {
                    self.tx_wasm_cache.pre_compile(&code);
                } else if name.starts_with("vp_") {
                    self.vp_wasm_cache.pre_compile(&code);
                }

                let code_key = Key::wasm_code(&code_hash);
                let code_len_key = Key::wasm_code_len(&code_hash);
                let hash_key = Key::wasm_hash(name);
                let code_name_key = Key::wasm_code_name(name.to_owned());

                self.wl_storage.write_bytes(&code_key, code).unwrap();
                self.wl_storage.write(&code_len_key, code_len).unwrap();
                self.wl_storage.write_bytes(&hash_key, code_hash).unwrap();
                if &Some(code_hash) == implicit_vp_code_hash {
                    is_implicit_vp_stored = true;
                }
                self.wl_storage
                    .write_bytes(&code_name_key, code_hash)
                    .unwrap();
            } else {
                tracing::warn!("The wasm {name} isn't whitelisted.");
                self.warn(Warning::WhitelistedWasm(name.to_string()));
            }
        }

        // check if implicit_vp wasm is stored
        if !is_implicit_vp_stored {
            self.register_err(Panic::MissingImplicitVP(
                match implicit_vp_code_hash {
                    None => "None".to_string(),
                    Some(h) => h.to_string(),
                },
            ));
        }

        self.proceed_with(())
    }

    /// Init genesis token accounts
    fn init_token_accounts(&mut self, genesis: &genesis::chain::Finalized) {
        let masp_rewards = address::tokens();
        for (alias, token) in &genesis.tokens.token {
            tracing::debug!("Initializing token {alias}");

            let FinalizedTokenConfig {
                address,
                config: TokenConfig { denom, parameters },
            } = token;
            // associate a token with its denomination.
            write_denom(&mut self.wl_storage, address, *denom).unwrap();
            parameters.init_storage(address, &mut self.wl_storage);
            // add token addresses to the masp reward conversions lookup table.
            let alias = alias.to_string();
            if masp_rewards.contains_key(&alias.as_str()) {
                self.wl_storage
                    .storage
                    .conversion_state
                    .tokens
                    .insert(alias, address.clone());
            }
        }
        let key_prefix: Key = address::masp().to_db_key().into();
        // Save the current conversion state
        let state_key = key_prefix
            .push(&(token::CONVERSION_KEY_PREFIX.to_owned()))
            .unwrap();
        let conv_bytes =
            self.wl_storage.storage.conversion_state.serialize_to_vec();
        self.wl_storage.write_bytes(&state_key, conv_bytes).unwrap();
    }

    /// Init genesis token balances
    fn init_token_balances(
        &mut self,
        genesis: &genesis::chain::Finalized,
    ) -> ControlFlow<()> {
        for (token_alias, TokenBalances(balances)) in &genesis.balances.token {
            tracing::debug!("Initializing token balances {token_alias}");

            let Some(token_address) = self.validate(genesis
                .tokens
                .token
                .get(token_alias)
                .ok_or_else(|| Panic::MissingTokenConfig(token_alias.to_string()))
                .map(|conf| &conf.address)
            )
            .or_placeholder(None)? else {
                continue
            };

            let mut total_token_balance = token::Amount::zero();
            for (owner_pk, balance) in balances {
                let owner = Address::from(&owner_pk.raw);
                storage_api::account::set_public_key_at(
                    &mut self.wl_storage,
                    &owner,
                    &owner_pk.raw,
                    0,
                )
                .unwrap();
                tracing::info!(
                    "Crediting {} {} tokens to {}",
                    balance,
                    token_alias,
                    owner_pk.raw
                );
                credit_tokens(
                    &mut self.wl_storage,
                    token_address,
                    &owner,
                    balance.amount,
                )
                .expect("Couldn't credit initial balance");
                total_token_balance += balance.amount;
            }
            // Write the total amount of tokens for the ratio
            self.wl_storage
                .write(
                    &token::minted_balance_key(token_address),
                    total_token_balance,
                )
                .unwrap();
        }
        self.proceed_with(())
    }

    /// Apply genesis txs to initialize established accounts
    fn apply_genesis_txs_established_account(
        &mut self,
        genesis: &genesis::chain::Finalized,
        vp_cache: &mut HashMap<String, Vec<u8>>,
    ) -> ControlFlow<()> {
        let vp_code = self.lookup_vp("vp_masp", genesis, vp_cache)?;
        let code_hash = CodeHash::sha256(&vp_code);
        self.wl_storage
            .write_bytes(&Key::validity_predicate(&address::masp()), code_hash)
            .unwrap();
        if let Some(txs) = genesis.transactions.established_account.as_ref() {
            for FinalizedEstablishedAccountTx {
                address,
                tx:
                    EstablishedAccountTx {
                        alias,
                        vp,
                        public_key,
                        storage,
                    },
            } in txs
            {
                tracing::debug!(
                    "Applying genesis tx to init an established account \
                     {alias}"
                );
                let vp_code = self.lookup_vp(vp, genesis, vp_cache)?;
                let code_hash = CodeHash::sha256(&vp_code);
                self.wl_storage
                    .write_bytes(&Key::validity_predicate(address), code_hash)
                    .unwrap();

                if let Some(pk) = public_key {
                    storage_api::account::set_public_key_at(
                        &mut self.wl_storage,
                        address,
                        &pk.pk.raw,
                        0,
                    )
                    .unwrap();
                }

                // Place the keys under the owners sub-storage
                let sub_key = namada::core::types::storage::Key::from(
                    address.to_db_key(),
                );
                for (key, value) in storage {
                    self.wl_storage
                        .write_bytes(&sub_key.join(key), value.parse().unwrap())
                        .unwrap();
                }
            }
        }
        self.proceed_with(())
    }

    /// Apply genesis txs to initialize validator accounts
    fn apply_genesis_txs_validator_account(
        &mut self,
        genesis: &genesis::chain::Finalized,
        vp_cache: &mut HashMap<String, Vec<u8>>,
        params: &PosParams,
        current_epoch: namada::types::storage::Epoch,
    ) -> ControlFlow<()> {
        if let Some(txs) = genesis.transactions.validator_account.as_ref() {
            for FinalizedValidatorAccountTx {
                address,
                tx:
                    ValidatorAccountTx {
                        alias,
                        vp,
                        dkg_key,
                        commission_rate,
                        max_commission_rate_change,
                        net_address: _,
                        account_key,
                        consensus_key,
                        protocol_key,
                        tendermint_node_key: _,
                        eth_hot_key,
                        eth_cold_key,
                    },
            } in txs
            {
                tracing::debug!(
                    "Applying genesis tx to init a validator account {alias}"
                );

                let vp_code = self.lookup_vp(vp, genesis, vp_cache)?;
                let code_hash = CodeHash::sha256(&vp_code);
                self.wl_storage
                    .write_bytes(&Key::validity_predicate(address), code_hash)
                    .expect("Unable to write user VP");
                // Validator account key
                storage_api::account::set_public_key_at(
                    &mut self.wl_storage,
                    address,
                    &account_key.pk.raw,
                    0,
                )
                .unwrap();

                self.wl_storage
                    .write(&protocol_pk_key(address), &protocol_key.pk.raw)
                    .expect("Unable to set genesis user protocol public key");

                self.wl_storage
                    .write(&dkg_session_keys::dkg_pk_key(address), &dkg_key.raw)
                    .expect(
                        "Unable to set genesis user public DKG session key",
                    );

                // TODO: replace pos::init_genesis validators arg with
                // init_genesis_validator from here
                if let Err(err) = pos::namada_proof_of_stake::become_validator(
                    BecomeValidator {
                        storage: &mut self.wl_storage,
                        params,
                        address,
                        consensus_key: &consensus_key.pk.raw,
                        protocol_key: &protocol_key.pk.raw,
                        eth_cold_key: &eth_cold_key.pk.raw,
                        eth_hot_key: &eth_hot_key.pk.raw,
                        current_epoch,
                        commission_rate: *commission_rate,
                        max_commission_rate_change: *max_commission_rate_change,
                        offset_opt: Some(0),
                    },
                ) {
                    tracing::warn!(
                        "Genesis init genesis validator tx for {alias} failed \
                         with {err}. Skipping."
                    );
                    self.warn(Warning::Validator(
                        alias.to_string(),
                        err.to_string(),
                    ));
                    continue;
                }
            }
        }
        self.proceed_with(())
    }

    /// Apply genesis txs to transfer tokens
    fn apply_genesis_txs_transfer(
        &mut self,
        genesis: &genesis::chain::Finalized,
    ) {
        if let Some(txs) = &genesis.transactions.transfer {
            for TransferTx {
                token,
                source,
                target,
                amount,
                ..
            } in txs
            {
                let token_addr = match genesis.get_token_address(token) {
                    Some(token) => {
                        tracing::debug!(
                            "Applying genesis tx to transfer {} of token \
                             {token} from {source} to {target}",
                            amount
                        );
                        token
                    }
                    None => {
                        tracing::warn!(
                            "Genesis token transfer tx uses an unknown token \
                             alias {token}. Skipping."
                        );
                        self.warn(Warning::BadToken(token.to_string()));
                        continue;
                    }
                };
                let target = match genesis.get_user_address(target) {
                    Some(target) => target,
                    None => {
                        tracing::warn!(
                            "Genesis token transfer tx uses an unknown target \
                             alias {target}. Skipping."
                        );
                        self.warn(Warning::UnknownTarget(target.to_string()));
                        continue;
                    }
                };
                let source: Address = (&source.raw).into();
                tracing::debug!(
                    "Transfer addresses: token {token} from {source} to \
                     {target}"
                );

                if let Err(err) = storage_api::token::transfer(
                    &mut self.wl_storage,
                    token_addr,
                    &source,
                    &target,
                    amount.amount,
                ) {
                    tracing::warn!(
                        "Genesis token transfer tx failed with: {err}. \
                         Skipping."
                    );
                    self.warn(Warning::FailedTransfer(
                        source.to_string(),
                        target.to_string(),
                        *amount,
                        token.to_string(),
                        err.to_string(),
                    ));
                    continue;
                };
            }
        }
    }

    /// Apply genesis txs to transfer tokens
    fn apply_genesis_txs_bonds(&mut self, genesis: &genesis::chain::Finalized) {
        let (current_epoch, _gas) = self.wl_storage.storage.get_current_epoch();
        if let Some(txs) = &genesis.transactions.bond {
            for BondTx {
                source,
                validator,
                amount,
                ..
            } in txs
            {
                tracing::debug!(
                    "Applying genesis tx to bond {} native tokens from \
                     {source} to {validator}",
                    amount,
                );

                let source = match source {
                    genesis::transactions::AliasOrPk::Alias(alias) => {
                        match genesis.get_user_address(alias) {
                            Some(addr) => addr,
                            None => {
                                tracing::warn!(
                                    "Cannot find bond source address with \
                                     alias \"{alias}\". Skipping."
                                );
                                self.warn(Warning::MissingBondAlias(
                                    alias.to_string(),
                                ));
                                continue;
                            }
                        }
                    }
                    genesis::transactions::AliasOrPk::PublicKey(pk) => {
                        Address::from(&pk.raw)
                    }
                };

                let validator = match genesis.get_validator_address(validator) {
                    Some(addr) => addr,
                    None => {
                        tracing::warn!(
                            "Cannot find bond validator address with alias \
                             \"{validator}\". Skipping."
                        );
                        self.warn(Warning::MissingValidatorAlias(
                            validator.to_string(),
                        ));
                        continue;
                    }
                };

                if let Err(err) = pos::namada_proof_of_stake::bond_tokens(
                    &mut self.wl_storage,
                    Some(&source),
                    validator,
                    amount.amount,
                    current_epoch,
                    Some(0),
                ) {
                    tracing::warn!(
                        "Genesis bond tx failed with: {err}. Skipping."
                    );
                    self.warn(Warning::FailedBond(
                        source.to_string(),
                        validator.to_string(),
                        *amount,
                        err.to_string(),
                    ));
                    continue;
                };
            }
        }
    }
}

/// A helper struct to accumulate errors in genesis files while
/// attempting to initialize the ledger
#[derive(Debug)]
pub struct InitChainValidation<'shell, D, H>
where
    D: DB + for<'iter> DBIter<'iter> + Sync + 'static,
    H: StorageHasher + Sync + 'static,
{
    /// Errors that can be encountered while initializing chain
    /// and are propagated up the stack in normal flow. Ultimately
    /// these are reported back to Comet BFT
    errors: Vec<Error>,
    /// Errors that cause `init_chain` to panic in normal flow but are not
    /// `expect` calls, so they could reasonably occur. These are demoted
    /// to errors while validating correctness of genesis files pre-network
    /// launch.
    panics: Vec<Panic>,
    /// Events that should not occur but would not prevent the chain from
    /// being successfully initialized. However, we don't reasonably expect
    /// to get any as these are checked as part of validating genesis
    /// templates.
    warnings: Vec<Warning>,
    dry_run: bool,
    shell: &'shell mut Shell<D, H>,
}

impl<'shell, D, H> std::ops::Deref for InitChainValidation<'shell, D, H>
where
    D: DB + for<'iter> DBIter<'iter> + Sync + 'static,
    H: StorageHasher + Sync + 'static,
{
    type Target = Shell<D, H>;

    fn deref(&self) -> &Self::Target {
        self.shell
    }
}

impl<'shell, D, H> std::ops::DerefMut for InitChainValidation<'shell, D, H>
where
    D: DB + for<'iter> DBIter<'iter> + Sync + 'static,
    H: StorageHasher + Sync + 'static,
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.shell
    }
}

impl<'shell, D, H> InitChainValidation<'shell, D, H>
where
    D: DB + for<'iter> DBIter<'iter> + Sync + 'static,
    H: StorageHasher + Sync + 'static,
{
    pub fn new(
        shell: &'shell mut Shell<D, H>,
        dry_run: bool,
    ) -> InitChainValidation<D, H> {
        Self {
            shell,
            errors: vec![],
            panics: vec![],
            warnings: vec![],
            dry_run,
        }
    }

    /// Print out a report of errors encountered while dry-running
    /// genesis files
    pub fn report(&self) {
        use color_eyre::owo_colors::{OwoColorize, Style};
        let separator: String = ["="; 60].into_iter().collect();
        println!(
            "\n\n{}\n{}\n{}\n\n",
            separator,
            "Report".bold().underline(),
            separator
        );
        if self.errors.is_empty()
            && self.panics.is_empty()
            && self.warnings.is_empty()
        {
            println!(
                "{}\n",
                "Genesis files were dry-run successfully"
                    .bright_green()
                    .underline()
            );
            return;
        }

        if !self.warnings.is_empty() {
            println!("{}\n\n", "Warnings".yellow().underline());
            let warnings = Style::new().yellow();
            for warning in &self.warnings {
                println!("{}\n", warning.to_string().style(warnings));
            }
        }

        if !self.errors.is_empty() {
            println!("{}\n\n", "Errors".magenta().underline());
            let errors = Style::new().magenta();
            for error in &self.errors {
                println!("{}\n", error.to_string().style(errors));
            }
        }

        if !self.panics.is_empty() {
            println!("{}\n\n", "Panics".bright_red().underline());
            let panics = Style::new().bright_red();
            for panic in &self.panics {
                println!("{}\n", panic.to_string().style(panics));
            }
        }
    }

    /// Add a warning
    fn warn(&mut self, warning: Warning) {
        self.warnings.push(warning);
    }

    /// Categorize an error as normal or something that would panic.
    fn register_err<E: Into<ErrorType>>(&mut self, err: E) {
        match err.into() {
            ErrorType::Runtime(e) => self.errors.push(e),
            ErrorType::DryRun(e) => self.panics.push(e),
        }
    }

    /// Categorize the error encountered and return a handle to allow
    /// the code to specify how to proceed.
    fn validate<T, E>(&mut self, res: std::result::Result<T, E>) -> Policy<T>
    where
        E: Into<ErrorType>,
    {
        match res {
            Ok(data) => Policy {
                result: Some(data),
                dry_run: self.dry_run,
            },
            Err(e) => {
                self.register_err(e);
                Policy {
                    result: None,
                    dry_run: self.dry_run,
                }
            }
        }
    }

    /// Check if any errors have been encountered
    fn is_ok(&self) -> bool {
        self.errors.is_empty() && self.panics.is_empty()
    }

    /// This should only be called after checking that `is_ok` returned false.
    fn error_out(mut self) -> Result<()> {
        if self.is_ok() {
            return Ok(());
        }
        if !self.panics.is_empty() {
            panic!(
                "Namada ledger failed to initialize due to: {}",
                self.panics.remove(0)
            );
        } else {
            Err(self.errors.remove(0))
        }
    }

    /// Used to indicate to the functions up the stack to begin panicking
    /// if not dry running a genesis file
    fn proceed_with<T>(&self, value: T) -> ControlFlow<(), T> {
        if self.dry_run || self.is_ok() {
            ControlFlow::Continue(value)
        } else {
            ControlFlow::Break(())
        }
    }
}

enum ErrorType {
    Runtime(Error),
    DryRun(Panic),
}

impl From<Error> for ErrorType {
    fn from(err: Error) -> Self {
        Self::Runtime(err)
    }
}

impl From<Panic> for ErrorType {
    fn from(err: Panic) -> Self {
        Self::DryRun(err)
    }
}

/// Changes the control flow of `init_chain` depending on whether
/// or not it is a dry-run. If so, errors / panics are accumulated to make
/// a report rather than immediately exiting.
struct Policy<T> {
    result: Option<T>,
    dry_run: bool,
}

impl<T> Policy<T> {
    /// A default value to return if an error / panic is encountered
    /// during a dry-run. This allows `init_chain` to continue.
    fn or_placeholder(self, value: Option<T>) -> ControlFlow<(), Option<T>> {
        if let Some(data) = self.result {
            ControlFlow::Continue(Some(data))
        } else if self.dry_run {
            ControlFlow::Continue(value)
        } else {
            ControlFlow::Break(())
        }
    }
}

#[cfg(all(test, not(feature = "integration")))]
mod test {
    use std::collections::BTreeMap;
    use std::str::FromStr;

    use namada::core::types::string_encoding::StringEncoded;
    use namada::ledger::storage::DBIter;
    use namada_sdk::wallet::alias::Alias;

    use super::*;
    use crate::config::genesis::transactions;
    use crate::config::genesis::transactions::AliasOrPk;
    use crate::node::ledger::shell::test_utils::{self, TestShell};
    use crate::wallet::defaults;

    /// Test that the init-chain handler never commits changes directly to the
    /// DB.
    #[test]
    fn test_init_chain_doesnt_commit_db() {
        let (shell, _recv, _, _) = test_utils::setup();

        // Collect all storage key-vals into a sorted map
        let store_block_state = |shell: &TestShell| -> BTreeMap<_, _> {
            shell
                .wl_storage
                .storage
                .db
                .iter_prefix(None)
                .map(|(key, val, _gas)| (key, val))
                .collect()
        };

        // Store the full state in sorted map
        let initial_storage_state: std::collections::BTreeMap<String, Vec<u8>> =
            store_block_state(&shell);

        // Store the full state again
        let storage_state: std::collections::BTreeMap<String, Vec<u8>> =
            store_block_state(&shell);

        // The storage state must be unchanged
        itertools::assert_equal(
            initial_storage_state.iter(),
            storage_state.iter(),
        );
    }

    /// Tests validation works properly on `lookup_vp`.
    /// This function can fail if
    /// *the wasm requested has no config in the genesis files
    /// * cannot be read from disk.
    #[test]
    fn test_dry_run_lookup_vp() {
        let (mut shell, _x, _y, _z) = TestShell::new_at_height(0);
        shell.wasm_dir = PathBuf::new();
        let mut initializer = InitChainValidation::new(&mut shell, true);
        let mut genesis = genesis::make_dev_genesis(1, PathBuf::new());

        let mut vp_cache = HashMap::new();
        let code = initializer.lookup_vp("vp_masp", &genesis, &mut vp_cache);
        assert_eq!(code, ControlFlow::Continue(vec![]));
        assert_eq!(
            *vp_cache.get("vp_masp.wasm").expect("Test failed"),
            Vec::<u8>::new()
        );
        let [Panic::ReadingWasm(_, _)]: [Panic; 1] = initializer.panics
            .clone()
            .try_into()
            .expect("Test failed") else {
            panic!("Test failed")
        };

        initializer.panics.clear();
        genesis.vps.wasm.remove("vp_masp").expect("Test failed");
        let code = initializer.lookup_vp("vp_masp", &genesis, &mut vp_cache);
        assert_eq!(code, ControlFlow::Continue(vec![]));
        let [Panic::MissingVpWasmConfig(_)]: [Panic; 1] = initializer.panics
            .clone()
            .try_into()
            .expect("Test failed") else {
            panic!("Test failed")
        };
    }

    /// Test validation of `store_wasms`.
    /// This can fail if
    /// * The checksums file cannot be found.
    /// * A wasm file in the checksums file cannot be read from disk
    /// * A checksum entry is invalid
    /// * A wasm's code hash does not match it's checksum entry
    /// * the wasm isn't whitelisted
    /// * no vp_implicit wasm is stored
    #[test]
    fn test_dry_run_store_wasms() {
        let (mut shell, _x, _y, _z) = TestShell::new_at_height(0);
        let test_dir = tempfile::tempdir().unwrap();
        shell.wasm_dir = test_dir.path().into();

        let mut initializer = InitChainValidation::new(&mut shell, true);
        let genesis = genesis::make_dev_genesis(1, PathBuf::new());

        let res = initializer
            .store_wasms(&genesis.get_chain_parameters(PathBuf::new()));
        assert_eq!(res, ControlFlow::Continue(()));
        let expected = vec![Panic::ChecksumsFile];
        assert_eq!(expected, initializer.panics);
        initializer.panics.clear();

        let checksums_file = test_dir.path().join("checksums.json");
        std::fs::write(
            &checksums_file,
            r#"{
            "tx_get_rich.wasm": "tx_get_rich.moneymoneymoney"
        }"#,
        )
        .expect("Test failed");
        let res = initializer
            .store_wasms(&genesis.get_chain_parameters(test_dir.path()));
        assert_eq!(res, ControlFlow::Continue(()));
        let errors = initializer.errors.iter().collect::<Vec<_>>();
        let [
            Error::ReadingWasm(_),
            Error::LoadingWasm(_),
        ]: [&Error; 2] = errors.try_into().expect("Test failed") else {
            panic!("Test failed");
        };
        let expected_panics = vec![
            Panic::Checksum("tx_get_rich.wasm".into()),
            Panic::MissingImplicitVP("None".into()),
        ];
        assert_eq!(initializer.panics, expected_panics);

        initializer.panics.clear();
        initializer.errors.clear();

        std::fs::write(
            checksums_file,
            r#"{
            "tx_stuff.wasm": "tx_stuff"
        }"#,
        )
        .expect("Test failed");
        let res = initializer
            .store_wasms(&genesis.get_chain_parameters(test_dir.path()));
        assert_eq!(res, ControlFlow::Continue(()));
        let errors = initializer.errors.iter().collect::<Vec<_>>();
        let [
            Error::ReadingWasm(_),
            Error::LoadingWasm(_),
            Error::LoadingWasm(_),
        ]: [&Error; 3] = errors.try_into().expect("Test failed") else {
            panic!("Test failed");
        };
        let expected_panics = vec![Panic::MissingImplicitVP("None".into())];
        assert_eq!(initializer.panics, expected_panics);
    }

    /// Test validation of `init_token_balance`.
    /// This can fail if a token alias with no
    /// corresponding config is encountered.
    #[test]
    fn test_dry_run_init_token_balance() {
        let (mut shell, _x, _y, _z) = TestShell::new_at_height(0);
        shell.wasm_dir = PathBuf::new();
        let mut initializer = InitChainValidation::new(&mut shell, true);
        let mut genesis = genesis::make_dev_genesis(1, PathBuf::new());
        let token_alias = Alias::from_str("apfel").unwrap();
        genesis
            .tokens
            .token
            .remove(&token_alias)
            .expect("Test failed");
        let res = initializer.init_token_balances(&genesis);
        assert_eq!(res, ControlFlow::Continue(()));
        let [Panic::MissingTokenConfig(_)]: [Panic; 1] = initializer.panics
            .clone()
            .try_into()
            .expect("Test failed") else {
            panic!("Test failed")
        };
    }

    /// Test validation of `apply_genesis_txs_transfer`
    /// This can fail if
    /// * A bad token alias used
    /// * A bad target alias is used
    /// * insufficient source funds
    #[test]
    fn test_dry_run_genesis_transfer() {
        let (mut shell, _x, _y, _z) = TestShell::new_at_height(0);
        shell.wasm_dir = PathBuf::new();
        let mut initializer = InitChainValidation::new(&mut shell, true);
        let mut genesis = genesis::make_dev_genesis(1, PathBuf::new());

        // remove the nam toke alias
        let token_alias = Alias::from_str("nam").unwrap();
        genesis
            .tokens
            .token
            .remove(&token_alias)
            .expect("Test failed");
        genesis.transactions.transfer = Some(vec![
            transactions::TransferTx {
                token: Alias::from_str("nam").unwrap(),
                source: StringEncoded {
                    raw: defaults::albert_keypair().ref_to(),
                },
                target: Alias::from_str("bertha").unwrap(),
                amount: token::DenominatedAmount {
                    amount: token::Amount::zero(),
                    denom: 6.into(),
                },
            },
            transactions::TransferTx {
                token: Alias::from_str("btc").unwrap(),
                source: StringEncoded {
                    raw: defaults::albert_keypair().ref_to(),
                },
                target: Alias::from_str("darth_vader").unwrap(),
                amount: token::DenominatedAmount {
                    amount: token::Amount::zero(),
                    denom: 6.into(),
                },
            },
            transactions::TransferTx {
                token: Alias::from_str("btc").unwrap(),
                source: StringEncoded {
                    raw: defaults::albert_keypair().ref_to(),
                },
                target: Alias::from_str("bertha").unwrap(),
                amount: token::DenominatedAmount {
                    amount: token::Amount::from_uint(3, 8).unwrap(),
                    denom: 8.into(),
                },
            },
        ]);
        // all transfers should fail as token balances have not been initialized
        initializer.apply_genesis_txs_transfer(&genesis);
        let expected = vec![
            Warning::BadToken("nam".into()),
            Warning::UnknownTarget("darth_vader".into()),
            Warning::FailedTransfer(
                "atest1d9khqw36x56rgvphx5erjwp48y6y2s6y89qnwdzygce5xsfkx9rrsd35xerrjdp3gsunz33n3zytee".into(),
                "atest1v4ehgw36xvcyyvejgvenxs34g3zygv3jxqunjd6rxyeyys3sxy6rwvfkx4qnj33hg9qnvse4lsfctw".into(),
                token::DenominatedAmount{ amount: token::Amount::from_uint(3, 8).unwrap(), denom: 8.into() },
                "btc".into(),
                "Insufficient source balance".into()
            ),
        ];
        assert_eq!(expected, initializer.warnings)
    }

    /// Test validation of `apply_genesis_txs_bonds`
    /// This can if
    /// * A bad source alias is given
    /// * A bad validator alias is given
    /// * Insufficient funds
    #[test]
    fn test_dry_run_genesis_bonds() {
        let (mut shell, _x, _y, _z) = TestShell::new_at_height(0);
        shell.wasm_dir = PathBuf::new();
        let mut initializer = InitChainValidation::new(&mut shell, true);
        let mut genesis = genesis::make_dev_genesis(1, PathBuf::new());

        // Initialize governance parameters
        let gov_params = genesis.get_gov_params();
        gov_params
            .init_storage(&mut initializer.wl_storage)
            .unwrap();
        // PoS system depends on epoch being initialized
        let pos_params = genesis.get_pos_params();
        let (current_epoch, _gas) =
            initializer.wl_storage.storage.get_current_epoch();
        pos::namada_proof_of_stake::init_genesis(
            &mut initializer.wl_storage,
            &pos_params,
            current_epoch,
        )
        .expect("Must be able to initialize PoS genesis storage");

        genesis.transactions.bond = Some(vec![
            transactions::BondTx {
                source: AliasOrPk::Alias(Alias::from_str("albert").unwrap()),
                validator: Alias::from_str("bertha").unwrap(),
                amount: token::DenominatedAmount {
                    amount: token::Amount::zero(),
                    denom: 6.into(),
                },
            },
            transactions::BondTx {
                source: AliasOrPk::Alias(
                    Alias::from_str("darth_vader").unwrap(),
                ),
                validator: Alias::from_str("validator-0").unwrap(),
                amount: token::DenominatedAmount {
                    amount: token::Amount::zero(),
                    denom: 6.into(),
                },
            },
            transactions::BondTx {
                source: AliasOrPk::Alias(Alias::from_str("albert").unwrap()),
                validator: Alias::from_str("validator-0").unwrap(),
                amount: token::DenominatedAmount {
                    amount: token::Amount::from_uint(1, 6).unwrap(),
                    denom: 6.into(),
                },
            },
        ]);
        // all bonds should fail as validators have not been initialized
        initializer.apply_genesis_txs_bonds(&genesis);
        let expected = vec![
            Warning::MissingValidatorAlias("bertha".into()),
            Warning::MissingBondAlias("darth_vader".into()),
            Warning::FailedBond(
                "atest1v4ehgw368ycryv2z8qcnxv3cxgmrgvjpxs6yg333gym5vv2zxepnj334g4rryvj9xucrgve4x3xvr4".into(),
                "atest1v4ehgw36ggcnsdee8qerswph8y6ry3p5xgunvve3xaqngd3kxc6nqwz9gseyydzzg5unys3ht2n48q".into(),
                token::DenominatedAmount{ amount: token::Amount::from_uint(1, 6).unwrap(), denom: 6.into() },
                "The given address atest1v4ehgw36ggcnsdee8qerswph8y6ry3p5xgunvve3xaqngd3kxc6nqwz9gseyydzzg5unys3ht2n48q is not a validator address".into()
            )];
        assert_eq!(expected, initializer.warnings);
    }
}
